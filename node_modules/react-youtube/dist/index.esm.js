"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _youtubePlayer = _interopRequireDefault(require("youtube-player"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Check whether a `props` change should result in the video being updated.
 *
 * @param {Object} prevProps
 * @param {Object} props
 */
function shouldUpdateVideo(prevProps, props) {
  // A changing video should always trigger an update
  if (prevProps.videoId !== props.videoId) {
    return true;
  } // Otherwise, a change in the start/end time playerVars also requires a player
  // update.


  var prevVars = prevProps.opts.playerVars || {};
  var vars = props.opts.playerVars || {};
  return prevVars.start !== vars.start || prevVars.end !== vars.end;
}
/**
 * Neutralize API options that only require a video update, leaving only options
 * that require a player reset. The results can then be compared to see if a
 * player reset is necessary.
 *
 * @param {Object} opts
 */


function filterResetOptions(opts) {
  return _objectSpread({}, opts, {
    playerVars: _objectSpread({}, opts.playerVars, {
      autoplay: 0,
      start: 0,
      end: 0
    })
  });
}
/**
 * Check whether a `props` change should result in the player being reset.
 * The player is reset when the `props.opts` change, except if the only change
 * is in the `start` and `end` playerVars, because a video update can deal with
 * those.
 *
 * @param {Object} prevProps
 * @param {Object} props
 */


function shouldResetPlayer(prevProps, props) {
  return !(0, _fastDeepEqual.default)(filterResetOptions(prevProps.opts), filterResetOptions(props.opts));
}
/**
 * Check whether a props change should result in an id or className update.
 *
 * @param {Object} prevProps
 * @param {Object} props
 */


function shouldUpdatePlayer(prevProps, props) {
  return prevProps.id !== props.id || prevProps.className !== props.className;
}

class YouTube extends _react.default.Component {
  /**
   * Expose PlayerState constants for convenience. These constants can also be
   * accessed through the global YT object after the YouTube IFrame API is instantiated.
   * https://developers.google.com/youtube/iframe_api_reference#onStateChange
   */
  constructor(props) {
    super(props);

    _defineProperty(this, "onPlayerReady", event => this.props.onReady(event));

    _defineProperty(this, "onPlayerError", event => this.props.onError(event));

    _defineProperty(this, "onPlayerStateChange", event => {
      this.props.onStateChange(event);

      switch (event.data) {
        case YouTube.PlayerState.ENDED:
          this.props.onEnd(event);
          break;

        case YouTube.PlayerState.PLAYING:
          this.props.onPlay(event);
          break;

        case YouTube.PlayerState.PAUSED:
          this.props.onPause(event);
          break;

        default:
      }
    });

    _defineProperty(this, "onPlayerPlaybackRateChange", event => this.props.onPlaybackRateChange(event));

    _defineProperty(this, "onPlayerPlaybackQualityChange", event => this.props.onPlaybackQualityChange(event));

    _defineProperty(this, "createPlayer", () => {
      // do not attempt to create a player server-side, it won't work
      if (typeof document === 'undefined') return; // create player

      var playerOpts = _objectSpread({}, this.props.opts, {
        // preload the `videoId` video if one is already given
        videoId: this.props.videoId
      });

      this.internalPlayer = (0, _youtubePlayer.default)(this.container, playerOpts); // attach event handlers

      this.internalPlayer.on('ready', this.onPlayerReady);
      this.internalPlayer.on('error', this.onPlayerError);
      this.internalPlayer.on('stateChange', this.onPlayerStateChange);
      this.internalPlayer.on('playbackRateChange', this.onPlayerPlaybackRateChange);
      this.internalPlayer.on('playbackQualityChange', this.onPlayerPlaybackQualityChange);
    });

    _defineProperty(this, "resetPlayer", () => this.internalPlayer.destroy().then(this.createPlayer));

    _defineProperty(this, "updatePlayer", () => {
      this.internalPlayer.getIframe().then(iframe => {
        if (this.props.id) iframe.setAttribute('id', this.props.id);else iframe.removeAttribute('id');
        if (this.props.className) iframe.setAttribute('class', this.props.className);else iframe.removeAttribute('class');
      });
    });

    _defineProperty(this, "updateVideo", () => {
      if (typeof this.props.videoId === 'undefined' || this.props.videoId === null) {
        this.internalPlayer.stopVideo();
        return;
      } // set queueing options


      var autoplay = false;
      var opts = {
        videoId: this.props.videoId
      };

      if ('playerVars' in this.props.opts) {
        autoplay = this.props.opts.playerVars.autoplay === 1;

        if ('start' in this.props.opts.playerVars) {
          opts.startSeconds = this.props.opts.playerVars.start;
        }

        if ('end' in this.props.opts.playerVars) {
          opts.endSeconds = this.props.opts.playerVars.end;
        }
      } // if autoplay is enabled loadVideoById


      if (autoplay) {
        this.internalPlayer.loadVideoById(opts);
        return;
      } // default behaviour just cues the video


      this.internalPlayer.cueVideoById(opts);
    });

    _defineProperty(this, "refContainer", container => {
      this.container = container;
    });

    this.container = null;
    this.internalPlayer = null;
  }

  componentDidMount() {
    this.createPlayer();
  }

  componentDidUpdate(prevProps) {
    if (shouldUpdatePlayer(prevProps, this.props)) {
      this.updatePlayer();
    }

    if (shouldResetPlayer(prevProps, this.props)) {
      this.resetPlayer();
    }

    if (shouldUpdateVideo(prevProps, this.props)) {
      this.updateVideo();
    }
  }

  componentWillUnmount() {
    /**
     * Note: The `youtube-player` package that is used promisifies all YouTube
     * Player API calls, which introduces a delay of a tick before it actually
     * gets destroyed. Since React attempts to remove the element instantly
     * this method isn't quick enough to reset the container element.
     */
    this.internalPlayer.destroy();
  }
  /**
   * https://developers.google.com/youtube/iframe_api_reference#onReady
   *
   * @param {Object} event
   *   @param {Object} target - player object
   */


  render() {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: this.props.containerClassName
    }, /*#__PURE__*/_react.default.createElement("div", {
      id: this.props.id,
      className: this.props.className,
      ref: this.refContainer
    }));
  }

}

_defineProperty(YouTube, "PlayerState", {
  UNSTARTED: -1,
  ENDED: 0,
  PLAYING: 1,
  PAUSED: 2,
  BUFFERING: 3,
  CUED: 5
});

YouTube.propTypes = {
  videoId: _propTypes.default.string,
  // custom ID for player element
  id: _propTypes.default.string,
  // custom class name for player element
  className: _propTypes.default.string,
  // custom class name for player container element
  containerClassName: _propTypes.default.string,
  // https://developers.google.com/youtube/iframe_api_reference#Loading_a_Video_Player
  opts: _propTypes.default.objectOf(_propTypes.default.any),
  // event subscriptions
  onReady: _propTypes.default.func,
  onError: _propTypes.default.func,
  onPlay: _propTypes.default.func,
  onPause: _propTypes.default.func,
  onEnd: _propTypes.default.func,
  onStateChange: _propTypes.default.func,
  onPlaybackRateChange: _propTypes.default.func,
  onPlaybackQualityChange: _propTypes.default.func
};
YouTube.defaultProps = {
  videoId: null,
  id: null,
  className: null,
  opts: {},
  containerClassName: '',
  onReady: () => {},
  onError: () => {},
  onPlay: () => {},
  onPause: () => {},
  onEnd: () => {},
  onStateChange: () => {},
  onPlaybackRateChange: () => {},
  onPlaybackQualityChange: () => {}
};
var _default = YouTube;
exports.default = _default;
